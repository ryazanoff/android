Основы Java. Типы данных и операции над ними. ООП в Java: абстракция, инкапсуляция, наследование, полиморфизм.


Первоначальный подход к программированию - алгоритмический (последовательный)
Что значит поставить чайник - включить плиту, помыть чайник, налить чайник и т .д.  
Но сложная программа ветвится, усложняется ( а вдруг то, а вдруг то ... )

Потом процедурное программирование. Повторяющиеся блоки начали выносить в процедуры. 

Написали процедуру пойти в магазин... а если пойти в другой магазин - другая процедура?
Следующий подход - ооп.

ООП отбрасывает понятие действий и переходит к концепции - всё вокруг нас - объекты
Объект - некоторая единица программы(логики). Можно считать, что весь мир состоит из объектов (машина, дом, человек, ... )
У объекта есть какие-то свойства, функции, можно что-то с ними сделать. В программе так же.
Свойства - цвет стола, вес... (Состояние - набор значений всех полей)
Поведение - это все методы объекта. Это методы по изменению его состояний!!!!

Подходя к ООП мы понимаем какие объекты там взамиодействуют. Например если это институт, то это студент, кафедра, предмет...
Когда появляется задача, нужно ее декомпозировать. Для этого и нужны парадигмы. 
ООП - парадигма, в которой всё из чего состоит программа - это объекты. 

UML диаграммы (draw.io)
 
1) Инкапсуляция. private,public.
Принцип - внутреннее состояние объекта должно быть защищено от воздействий из вне и должно производиться только с помощью методов. Любой дурак может написать программу понятную компьютеру. Только хороший программист пишет прогорамму понятную человкеку. Программа должна быть читаема(если ты сядешь его читать через пару лет) (КАРТИНКА ПРО ООП)

Представьте, что у Вас не заводится машина и Вы, увы, не механик и плохо разбираетесь в машинах. Вы открываете капот и начинаете выдергивать какие-то шланги, что-то окручивать. и т.д. Хорошо, если Вы запомнили что, где и как выдергивали и откручивали. А если нет ? Или, у Вас стрелка уровня топлива стоит на нуле, а Вы считаете, что у Вас полно топлива и полезете со спичками внутрь бензобака проверять уровень топлива. Какие последствия Вас могут ожидать ? В лучшем случае Вы и Ваша машина останутся живы, если Вам о-о-очень повезет.

Аналогично и с нашими объектами, которые могут быть чрезвычайно сложными, а Вы пытаетесь что-то в них подправить, не представляя их внутреннюю организацию.

2) Наследование
Позволяет всем наследникам класса обладать такими же свойствами и методами
Проблема в том, что когда у нас длинное дерево наследований. то невозможно сказать какие будут методы у объекта, т.к. надо пробежаться по всей цепочке и собрать все методы.
Вторая проблема - если мы унаследовались, то как посчитать кол-во объектов
Вызвать метод чужого класса - делегирвоание. Иногда предпочтительнее чем 

Метод, который описан в родители, но не задан как он работает называется АБСТРАКТНЫМ (Например нету просто "Животное". Все животные дышат по-разному)
Сигнатура
Абстрактный метод только в абстрактном классе. Класс абстрактный, если хотя бы один метод абстрактный. Экземпляр абстрактного класса мы не можем создать. Можно создать абстрактый класс и прописать в нем все методы абстрактными. Выдаст ошибку на этапе компиляции, что УДОБНО. Большинство таких ситуаций вынесено на этап компиляции.

Интерфейс - класс у которого ВСЕ методы абстрактные. Он задает просто сигнатуры методов. Множественного наследования нет, но можно множество интерфейсов . (extends 1 , implenets много , т.е. много имплементаций)
Когда создается новый класс, то нужно происать ВСЕ методы. Если хотя бы один метод не прописали, то надо сделать класс абстрактным. 

Основная проблема, почему нет ромбовидного наследования - проблема ромбовидного наследования. Множественное наслеодование усложняет код.

А зачем много интерфейсов? Отдельным классам можно сказать, что они имплементируют. Дерево наследования лучше вести снизу.

Наследоваться от чужих классов (библиотек) лучше не делать

3) Полиморфизм
Это возможность обращаться со всеми наследниками одинаковым образом
Полиморфизм позволяет избежать больших блоков if (если объект типа такого то, то .... , если иначае, то ... )
То есть создавая класс Кошка - это будет еще и животное. И можно вызвать констурктор, и обращаться как к животному.



Java относится к языкам объектно-ориентированного типа,  поэтому, прежде чем приступать к написанию программ, следует познакомиться с принципами объектно-ориентированного программирования.
Основные понятия в ООП - `объект`, `интерфейс` и `класс`. 

Класс - абстрактное описание группы объектов, которе мы хотим унифицировать и суженное до конкретных свойств объекта. 

Класс Robot может состоять из таких атрибутов как:

ID
имя
тип
цвет
вес
скорость передвижения
…
можно придумать много других атрибутов.

Также класс Robot будет содержать методы, отвечающие за его поведение. К примеру, на начальном этапе робот умеет:

Спрашивать имя
Приветствовать по имени
Выполнять какую-либо работу
Абстракция

Важно помнить, что описывая поведение какого-либо объекта, нужно выбрать подходящий для решения конкретной задачи уровень абстракции. Объекты реального света могут быть достаточно сложны, чтобы описать все их характеристики, более того, решение конкретных задач потребует лишь наличие некоторых из них. Таким образом, мы должны абстрагироваться от некоторых конкретных деталей объекта. Но также важно, чтобы абстракция не была слишком обобщенной и позволила правильно моделировать поведение объекта.

Далее рассмотрим 3 главных принципа, на которых строится объектно-ориентированное программирование:

Инкапсуляция (public,private)
Наследование (extends, implements)
Полиморфизм (единый интерфейс для унаследованных типов)
Инкапсуляция

Инкапсуляция это механизм, объединяющий атрибуты и методы (которые составляют объект) и охраняющий их от внешнего вмешательства.  Инкапсуляция — защитная оболочка, позволяющая обращаться к атрибутам и методам класса только внутри этого класса или при помощи специально спроектированного  интерфейса.

Атрибуты или методы класса могут быть открытыми (public) или закрытыми (private). Закрытые атрибуты и методы могут быть доступны только внутри класса, в котором они находятся, они не доступны той части программного кода, которая находится вне этого класса. Открытые атрибуты и методы доступны, в том числе, и коду программы вне класса. Таким образом, открытые методы используются для предоставления контролируемого интерфейса к закрытым элементам класса.

Например, представим, что у нашего робота на голове находятся светодиоды, которые меняют цвет по голосовой команде «Измени цвет».  Мы не можем ни как по-другому повлиять на смену цвета диодов, потому что этого не позволят настройки приватности. Мы можем повлиять на смену цвета, только при помощи конкретной голосовой команды, которая в данном случае является интерфейсом к светодиодам.

Наследование

Наследование помогает избежать дублирования кода в случае, если нам нужно создать объект на основе уже существующего. В этом случае говорится, что новый объект (дочерний) унаследовал свойства уже существующего (родительского). Если атрибуты или поведение существующего объекта нужно частично изменить, то  их можно просто переопределить.

Например, на основе  уже существующего объекта Robot мы можем создать новый объект CoffeRobot, который будет варить кофе. Новый робот будет иметь все атрибуты и методы что и предыдущий, плюс содержать дополнительный метод «Варить кофе».

Полиморфизм

Если мы имеем объекты, которые принадлежат одной и той же ветви иерархии (были унаследованы), то для них можно использовать единый интерфейс, который будет для каждого объекта производить однотипное действие, но результат для каждого объекта будет различным (зависящим от этого конкретного объекта).

Например, если мы при помощи наследования создадим серию роботов разных типов (робот, который варит кофе; робот, который моет пол; робот, который поливает цветы), а потом каждому роботу дадим команду «работай», то каждый робот в ответ на ту же самую команду будет делать различные действия, в соответствии с его типом. То есть, единым интерфейсом здесь является объект Robot с методом «работать», а то, как именно он будет работать, зависит от его реализации.

Методы.
Можно создавать методы с одним названием и разным числом параметров. Можно задавать вообще список параметров
